"use client";

import { useState, useEffect, useRef } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { FormField } from "@/components/admin/forms/FormField";
import { ImageUploadField } from "@/components/admin/forms/ImageUploadField";
import { ShadowInput } from "@/components/admin/ShadowInput";
import { ShadowTextarea } from "@/components/admin/ShadowTextarea";
import { ShadowButton } from "@/components/admin/ShadowButton";
import { toast } from "sonner";
import { supabase } from "@/lib/supabase";

const artistSchema = z.object({
  name: z.string().min(1, "Name is required"),
  slug: z.string().min(1, "Slug is required"),
  bio: z
    .string()
    .optional()
    .transform((val) => (val === "" || !val ? undefined : val)),
  profile_image_url: z
    .union([z.string().url("Please enter a valid URL"), z.literal("")])
    .optional()
    .transform((val) => (val === "" || !val ? undefined : val)),
});

type ArtistFormData = {
  name: string;
  slug: string;
  bio?: string;
  profile_image_url?: string;
};

type CreateArtistModalProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess: (artist: { id: string; name: string; profile_image_url: string | null }) => void;
};

export function CreateArtistModal({ open, onOpenChange, onSuccess }: CreateArtistModalProps) {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const lastAutoGeneratedSlugRef = useRef<string>("");
  const slugManuallyEditedRef = useRef<boolean>(false);

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    setValue,
    watch,
    reset,
  } = useForm<ArtistFormData>({
    resolver: zodResolver(artistSchema),
    defaultValues: {
      name: "",
      slug: "",
      bio: "",
      profile_image_url: "",
    },
  });

  // Reset form when modal closes
  useEffect(() => {
    if (!open) {
      reset();
      setSelectedFile(null);
      lastAutoGeneratedSlugRef.current = "";
      slugManuallyEditedRef.current = false;
    }
  }, [open, reset]);

  const validateImageUrl = async (url: string): Promise<{ valid: boolean; error?: string }> => {
    try {
      const response = await fetch("/api/admin/upload/validate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ imageUrl: url }),
      });
      const data = await response.json();
      return { valid: data.valid || false, error: data.error };
    } catch (error: any) {
      return { valid: false, error: error.message || "Failed to validate image" };
    }
  };

  const nameValue = watch("name");
  const slugValue = watch("slug");

  // Auto-generate slug from name
  useEffect(() => {
    if (nameValue && open && !slugManuallyEditedRef.current) {
      const autoSlug = nameValue
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-|-$/g, "");

      // Auto-update if:
      // 1. Slug is empty, OR
      // 2. Slug matches the last auto-generated slug (meaning it's still auto-generated)
      const shouldAutoUpdate = !slugValue || slugValue === lastAutoGeneratedSlugRef.current;

      if (shouldAutoUpdate) {
        setValue("slug", autoSlug, { shouldValidate: false });
        lastAutoGeneratedSlugRef.current = autoSlug;
      }
    }
  }, [nameValue, slugValue, setValue, open]);

  // Track manual slug edits
  useEffect(() => {
    if (slugValue && nameValue && open) {
      const autoSlug = nameValue
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-|-$/g, "");

      if (slugValue !== autoSlug && slugValue !== lastAutoGeneratedSlugRef.current) {
        slugManuallyEditedRef.current = true;
      } else if (slugValue === autoSlug) {
        slugManuallyEditedRef.current = false;
      }
    }
  }, [slugValue, nameValue, open]);

  const onSubmit = async (data: ArtistFormData) => {
    try {
      const newImageUrl = data.profile_image_url?.trim() || null;
      let finalImageUrl = newImageUrl;

      // If there's a selected file, upload it to Bunny
      if (selectedFile) {
        try {
          const formData = new FormData();
          formData.append("file", selectedFile);
          formData.append("folderPath", "artists/temp");
          const uploadResponse = await fetch("/api/admin/upload", {
            method: "POST",
            body: formData,
          });
          if (!uploadResponse.ok) {
            const error = await uploadResponse.json();
            throw new Error(error.error || "Failed to upload image");
          }
          const uploadData = await uploadResponse.json();
          finalImageUrl = uploadData.url;
        } catch (uploadError: any) {
          console.error("Error uploading image:", uploadError);
          toast.error(uploadError.message || "Failed to upload image");
          return;
        }
      } else if (newImageUrl && !newImageUrl.includes("mihaipol-com.b-cdn.net")) {
        // If URL is provided and it's not from our CDN, validate and upload it to Bunny
        const validation = await validateImageUrl(newImageUrl);
        if (!validation.valid) {
          toast.error(
            validation.error ||
              "Image not supported or not accessible. Please check the URL or upload a file."
          );
          return;
        }
        try {
          const formData = new FormData();
          formData.append("imageUrl", newImageUrl);
          formData.append("folderPath", "artists/temp");
          const uploadResponse = await fetch("/api/admin/upload", {
            method: "POST",
            body: formData,
          });
          if (!uploadResponse.ok) {
            const error = await uploadResponse.json();
            throw new Error(error.error || "Failed to upload image from URL");
          }
          const uploadData = await uploadResponse.json();
          finalImageUrl = uploadData.url;
        } catch (uploadError: any) {
          console.error("Error uploading image from URL:", uploadError);
          toast.error(uploadError.message || "Failed to upload image from URL");
          return;
        }
      }

      const submitData = {
        name: data.name,
        slug: data.slug,
        bio: data.bio || null,
        profile_image_url: finalImageUrl || null,
      };

      const { data: sessionData } = await supabase.auth.getSession();
      const accessToken = sessionData?.session?.access_token;

      const response = await fetch("/api/admin/artists", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          ...(accessToken ? { Authorization: `Bearer ${accessToken}` } : {}),
        },
        body: JSON.stringify(submitData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        const errorMessage = errorData.error || errorData.message || "Failed to create artist";
        if (errorData.details) {
          const details = errorData.details;
          if (details.fieldErrors) {
            const fieldErrors = Object.entries(details.fieldErrors)
              .map(
                ([field, errors]: [string, any]) =>
                  `${field}: ${Array.isArray(errors) ? errors.join(", ") : errors}`
              )
              .join("\n");
            throw new Error(`${errorMessage}\n${fieldErrors}`);
          }
        }
        throw new Error(errorMessage);
      }

      const created = await response.json();

      // Move from temp to permanent if needed
      if (finalImageUrl && finalImageUrl.includes("/artists/temp/") && created?.id) {
        try {
          const moveResponse = await fetch("/api/admin/upload/move", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              imageUrl: finalImageUrl,
              newFolderPath: `artists/${created.id}`,
            }),
          });
          if (moveResponse.ok) {
            const moveData = await moveResponse.json();
            await fetch("/api/admin/artists", {
              method: "PUT",
              headers: {
                "Content-Type": "application/json",
                ...(accessToken ? { Authorization: `Bearer ${accessToken}` } : {}),
              },
              body: JSON.stringify({ id: created.id, profile_image_url: moveData.url }),
            });
          }
        } catch (moveError) {
          console.error("Failed to move image from temp folder:", moveError);
        }
      }

      toast.success("Artist created successfully");
      onSuccess({
        id: created.id,
        name: created.name,
        profile_image_url: finalImageUrl || null,
      });
      onOpenChange(false);
    } catch (error: any) {
      console.error("Error creating artist:", error);
      const errorMessage = error?.message || "Failed to create artist";
      toast.error(errorMessage, {
        duration: 5000,
      });
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Create New Artist</DialogTitle>
          <DialogDescription>
            Add a new artist profile. It will be available immediately for selection.
          </DialogDescription>
        </DialogHeader>
        <form
          onSubmit={(e) => {
            e.preventDefault();
            e.stopPropagation();
            handleSubmit(onSubmit)(e);
          }}
          className="space-y-6 mt-4"
        >
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <FormField label="Name" required error={errors.name?.message}>
              <ShadowInput {...register("name")} placeholder="Artist name" />
            </FormField>

            <FormField label="Slug" required error={errors.slug?.message}>
              <ShadowInput
                {...register("slug")}
                placeholder="artist-slug"
                className="font-mono text-sm"
              />
            </FormField>
          </div>

          <FormField label="Bio" error={errors.bio?.message}>
            <ShadowTextarea
              {...register("bio")}
              placeholder="Enter a brief biography..."
              rows={4}
              className="resize-none"
            />
          </FormField>

          <FormField label="Profile Image" error={errors.profile_image_url?.message}>
            <ImageUploadField
              value={watch("profile_image_url") || null}
              onChange={(url) => setValue("profile_image_url", url || "")}
              onFileChange={(file) => setSelectedFile(file)}
              folderPath="artists/temp"
              error={errors.profile_image_url?.message}
              placeholder="https://example.com/profile.jpg"
            />
          </FormField>

          <div className="flex gap-4 justify-end pt-4">
            <ShadowButton type="button" variant="outline" onClick={() => onOpenChange(false)}>
              Cancel
            </ShadowButton>
            <ShadowButton type="submit" disabled={isSubmitting}>
              {isSubmitting ? "Creating..." : "Create Artist"}
            </ShadowButton>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}

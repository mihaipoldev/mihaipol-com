"use client";

import { useState, useEffect, useRef } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { FormField } from "@/components/admin/forms/FormField";
import { ImageUploadField } from "@/components/admin/forms/ImageUploadField";
import { ShadowInput } from "@/components/admin/ShadowInput";
import { ShadowTextarea } from "@/components/admin/ShadowTextarea";
import { ShadowButton } from "@/components/admin/ShadowButton";
import { toast } from "sonner";
import { supabase } from "@/lib/supabase";

const labelSchema = z.object({
  name: z.string().min(1, "Name is required"),
  slug: z.string().min(1, "Slug is required"),
  description: z
    .string()
    .optional()
    .transform((val) => (val === "" || !val ? undefined : val)),
  website_url: z
    .union([z.string().url("Please enter a valid URL"), z.literal("")])
    .optional()
    .transform((val) => (val === "" || !val ? undefined : val)),
  logo_image_url: z
    .union([z.string().url("Please enter a valid URL"), z.literal("")])
    .optional()
    .transform((val) => (val === "" || !val ? undefined : val)),
});

type LabelFormData = {
  name: string;
  slug: string;
  description?: string;
  website_url?: string;
  logo_image_url?: string;
};

type CreateLabelModalProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess: (label: { id: string; name: string }) => void;
};

export function CreateLabelModal({ open, onOpenChange, onSuccess }: CreateLabelModalProps) {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const lastAutoGeneratedSlugRef = useRef<string>("");
  const slugManuallyEditedRef = useRef<boolean>(false);

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    setValue,
    watch,
    reset,
  } = useForm<LabelFormData>({
    resolver: zodResolver(labelSchema),
    defaultValues: {
      name: "",
      slug: "",
      description: "",
      website_url: "",
      logo_image_url: "",
    },
  });

  // Reset form when modal closes
  useEffect(() => {
    if (!open) {
      reset();
      setSelectedFile(null);
      lastAutoGeneratedSlugRef.current = "";
      slugManuallyEditedRef.current = false;
    }
  }, [open, reset]);

  const validateImageUrl = async (url: string): Promise<{ valid: boolean; error?: string }> => {
    try {
      const response = await fetch("/api/admin/upload/validate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ imageUrl: url }),
      });
      const data = await response.json();
      return { valid: data.valid || false, error: data.error };
    } catch (error: any) {
      return { valid: false, error: error.message || "Failed to validate image" };
    }
  };

  const nameValue = watch("name");
  const slugValue = watch("slug");

  // Auto-generate slug from name
  useEffect(() => {
    if (nameValue && open && !slugManuallyEditedRef.current) {
      const autoSlug = nameValue
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-|-$/g, "");

      // Auto-update if:
      // 1. Slug is empty, OR
      // 2. Slug matches the last auto-generated slug (meaning it's still auto-generated)
      const shouldAutoUpdate = !slugValue || slugValue === lastAutoGeneratedSlugRef.current;

      if (shouldAutoUpdate) {
        setValue("slug", autoSlug, { shouldValidate: false });
        lastAutoGeneratedSlugRef.current = autoSlug;
      }
    }
  }, [nameValue, slugValue, setValue, open]);

  // Track manual slug edits - only mark as edited if slug doesn't match auto-generated from current name
  useEffect(() => {
    if (slugValue && nameValue && open) {
      const autoSlug = nameValue
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-|-$/g, "");

      // If slug doesn't match what would be auto-generated AND doesn't match last auto-generated,
      // then it was manually edited
      if (slugValue !== autoSlug && slugValue !== lastAutoGeneratedSlugRef.current) {
        slugManuallyEditedRef.current = true;
      } else if (slugValue === autoSlug) {
        // If it matches the auto-generated slug, reset the manual edit flag
        slugManuallyEditedRef.current = false;
      }
    }
  }, [slugValue, nameValue, open]);

  const onSubmit = async (data: LabelFormData) => {
    try {
      const newImageUrl = data.logo_image_url?.trim() || null;
      let finalImageUrl = newImageUrl;

      // If there's a selected file, upload it to Bunny
      if (selectedFile) {
        try {
          const formData = new FormData();
          formData.append("file", selectedFile);
          formData.append("folderPath", "labels/temp");
          const uploadResponse = await fetch("/api/admin/upload", {
            method: "POST",
            body: formData,
          });
          if (!uploadResponse.ok) {
            const error = await uploadResponse.json();
            throw new Error(error.error || "Failed to upload image");
          }
          const uploadData = await uploadResponse.json();
          finalImageUrl = uploadData.url;
        } catch (uploadError: any) {
          console.error("Error uploading image:", uploadError);
          toast.error(uploadError.message || "Failed to upload image");
          return;
        }
      } else if (newImageUrl && !newImageUrl.includes("mihaipol-com.b-cdn.net")) {
        // If URL is provided and it's not from our CDN, validate and upload it to Bunny
        const validation = await validateImageUrl(newImageUrl);
        if (!validation.valid) {
          toast.error(
            validation.error ||
              "Image not supported or not accessible. Please check the URL or upload a file."
          );
          return;
        }
        try {
          const formData = new FormData();
          formData.append("imageUrl", newImageUrl);
          formData.append("folderPath", "labels/temp");
          const uploadResponse = await fetch("/api/admin/upload", {
            method: "POST",
            body: formData,
          });
          if (!uploadResponse.ok) {
            const error = await uploadResponse.json();
            throw new Error(error.error || "Failed to upload image from URL");
          }
          const uploadData = await uploadResponse.json();
          finalImageUrl = uploadData.url;
        } catch (uploadError: any) {
          console.error("Error uploading image from URL:", uploadError);
          toast.error(uploadError.message || "Failed to upload image from URL");
          return;
        }
      }

      const submitData = {
        name: data.name,
        slug: data.slug,
        description: data.description || null,
        website_url: data.website_url || null,
        logo_image_url: finalImageUrl || null,
      };

      const { data: sessionData } = await supabase.auth.getSession();
      const accessToken = sessionData?.session?.access_token;

      const response = await fetch("/api/admin/labels", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          ...(accessToken ? { Authorization: `Bearer ${accessToken}` } : {}),
        },
        body: JSON.stringify(submitData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        const errorMessage = errorData.error || errorData.message || "Failed to create label";
        if (errorData.details) {
          const details = errorData.details;
          if (details.fieldErrors) {
            const fieldErrors = Object.entries(details.fieldErrors)
              .map(
                ([field, errors]: [string, any]) =>
                  `${field}: ${Array.isArray(errors) ? errors.join(", ") : errors}`
              )
              .join("\n");
            throw new Error(`${errorMessage}\n${fieldErrors}`);
          }
        }
        throw new Error(errorMessage);
      }

      const created = await response.json();

      // Move from temp to permanent if needed
      if (finalImageUrl && finalImageUrl.includes("/labels/temp/") && created?.id) {
        try {
          const moveResponse = await fetch("/api/admin/upload/move", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              imageUrl: finalImageUrl,
              newFolderPath: `labels/${created.id}`,
            }),
          });
          if (moveResponse.ok) {
            const moveData = await moveResponse.json();
            await fetch("/api/admin/labels", {
              method: "PUT",
              headers: {
                "Content-Type": "application/json",
                ...(accessToken ? { Authorization: `Bearer ${accessToken}` } : {}),
              },
              body: JSON.stringify({ id: created.id, logo_image_url: moveData.url }),
            });
          }
        } catch (moveError) {
          console.error("Failed to move image from temp folder:", moveError);
        }
      }

      toast.success("Label created successfully");
      onSuccess({ id: created.id, name: created.name });
      onOpenChange(false);
    } catch (error: any) {
      console.error("Error creating label:", error);
      const errorMessage = error?.message || "Failed to create label";
      toast.error(errorMessage, {
        duration: 5000,
      });
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Create New Label</DialogTitle>
          <DialogDescription>
            Add a new record label or distributor. It will be available immediately for selection.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-6 mt-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <FormField label="Name" required error={errors.name?.message}>
              <ShadowInput {...register("name")} placeholder="Label name" />
            </FormField>

            <FormField label="Slug" required error={errors.slug?.message}>
              <ShadowInput
                {...register("slug")}
                placeholder="label-slug"
                className="font-mono text-sm"
              />
            </FormField>
          </div>

          <FormField label="Description" error={errors.description?.message}>
            <ShadowTextarea
              {...register("description")}
              placeholder="Enter a brief description of the label..."
              rows={4}
              className="resize-none"
            />
          </FormField>

          <FormField label="Website URL" error={errors.website_url?.message}>
            <ShadowInput
              type="url"
              {...register("website_url")}
              placeholder="https://example.com"
            />
          </FormField>

          <FormField label="Logo Image" error={errors.logo_image_url?.message}>
            <ImageUploadField
              value={watch("logo_image_url") || null}
              onChange={(url) => setValue("logo_image_url", url || "")}
              onFileChange={(file) => setSelectedFile(file)}
              folderPath="labels/temp"
              error={errors.logo_image_url?.message}
              placeholder="https://example.com/logo.jpg"
            />
          </FormField>

          <div className="flex gap-4 justify-end pt-4">
            <ShadowButton type="button" variant="outline" onClick={() => onOpenChange(false)}>
              Cancel
            </ShadowButton>
            <ShadowButton type="submit" disabled={isSubmitting}>
              {isSubmitting ? "Creating..." : "Create Label"}
            </ShadowButton>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
